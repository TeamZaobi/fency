# Index.html 重构计划与技术规范

> **⚠️ 未来规划文档 ⚠️**
>
> 本文档描述了项目的未来发展方向，与当前实施的手动维护模式有所冲突。参考 [项目需求文档](./prd.md) 了解项目整体规划。当前的内容处理工作流程请参考 [内容处理工作流](./content-processing-workflow.md)。

本文档概述了重构 `index.html` 的计划，目标是将其转变为一个动态的内容聚合器。

## 0. 预备阶段：内容迁移与元数据初始化

在开始核心重构工作之前，需要完成以下准备步骤：

1.  **内容迁移与修正:**
    *   编写并执行脚本（例如，使用 Node.js 文件系统 API）来识别 `react-app/` 下的内容页面，并根据预定义的分类规则（或通过分析页面内容推断）将其移动到 `html/pages/` 下的相应子目录。
    *   利用 HTML 解析库（如 Cheerio 或 JSDOM）分析每个迁移的 HTML 文件，并补充或修正 `<head>` 中的元数据标签（`<title>`, `<meta name="description">`, `<meta name="category">`, `<meta name="publish-date">`, `<meta name="keywords">`）。这可能涉及调用 LLM API 来生成描述或关键词。
    *   在页面合适位置（如页脚）插入返回首页的链接和作者信息（基于预设模板或对页面结构的分析）。
    *   在页面可见内容中添加发布日期和分类标签，以符合 `web-dev.mdc` 规则 D.4 (接受自动化可能失败或效果不佳的风险)。
    *   运行代码分析和检查，对修改的元数据（特别是描述和关键词）的相关性进行评估，并记录任何低置信度或潜在问题的分析结果。
2.  **元数据初始化:**
    *   编写并执行一个一次性的 Node.js 脚本 (`scripts/generate-initial-metadata.js`)。
    *   该脚本将使用文件系统 API 扫描 `html/pages/` 目录，利用 HTML 解析库提取每个文件所需的元数据，并通过系统调用获取文件的 `lastModifiedDate`，最终构建并以原子方式写入初始的 `html/metadata.json` 文件。
    *   对生成的脚本执行静态代码分析（如检查错误处理、未使用的变量、潜在的逻辑问题）。

## 1. 核心目标

*   `index.html` 通过客户端 JavaScript **动态渲染**卡片列表。
*   内容发布流程**完全自动化** `html/metadata.json` 的维护（通过在 `.cursor/rules/web-dev.mdc` 中配置，在生成新页面后调用更新脚本完成）。

## 2. 架构选型

*   **渲染模式:** 客户端渲染 (Client-Side Rendering - CSR)。
    *   **选择理由:** 与交互式功能的需求契合，避免了复杂的服务器端渲染或构建步骤。
*   **元数据存储:** 使用 `html/metadata.json` 文件。
    *   **选择理由:** 结构简单，易于通过脚本进行读写和版本控制。

## 3. 技术栈

*   **HTML:** HTML5
*   **CSS:** Tailwind CSS (通过 CDN 引入，易于自动化集成) 或 自定义 CSS (`html/css/style.css`)
*   **核心脚本语言:** TypeScript (`html/js/main.ts`)，编译为 JavaScript (`html/js/main.js`)。
    *   **选择理由:** 提供类型安全，利于代码分析和重构。
*   **构建工具 (编译 TS):** `tsc` (TypeScript 编译器)。
    *   **选择理由:** TypeScript 官方工具，集成简单，满足基本编译需求。

## 4. 核心组件与规范

*   **`html/index.html`:**
    *   创建基础结构，包含必要的元素和空的分类容器。通过解析生成的 HTML 并检查关键元素 ID 进行验证。
*   **`html/metadata.json`:**
    *   根据 `types.ts` 中的接口定义创建结构。初始文件由脚本生成。通过 JSON Schema 或类似机制验证文件格式。
*   **`html/js/main.ts`:**
    *   编写代码，实现元数据加载、动态卡片渲染、主题切换等功能。
    *   使用 Linter (如 ESLint) 进行代码风格和潜在错误检查，并运行编译命令 (`npm run build`) 进行类型检查和基础构建验证。
*   **`.cursor/rules/web-dev.mdc`:**
    *   基于项目目标和技术栈创建和更新规则。通过测试环节验证规则的有效性。
    *   明确包含调用元数据更新脚本的指令。
*   **元数据更新脚本 (`scripts/update-metadata.js`):**
    *   编写脚本，包含解析 HTML、更新 JSON 和原子写入逻辑。
    *   执行静态代码分析和基础的功能测试来验证脚本逻辑，特别是文件写入和错误处理部分。

## 5. 实施路线图

0.  **阶段 0: 内容迁移、修正与元数据初始化**
1.  **阶段 1: 基础结构生成与验证**
2.  **阶段 2: 动态卡片渲染逻辑编写与测试**
3.  **阶段 3: 样式与交互实现与测试**
4.  **阶段 4: 元数据更新流程实现与测试**

## 6. 技术风险与缓解

*   **`metadata.json` 损坏:**
    *   **缓解:** 脚本强制采用原子写入。实现定期备份机制。
*   **关键词/元数据质量:**
    *   **缓解:** 优化 LLM prompt 和增加验证逻辑来提高元数据质量。分析将标记低置信度项，但接受质量可能不如人工审核。
*   **脚本健壮性:**
    *   **缓解:** 编写包含详细错误处理和日志记录的脚本。执行静态分析和单元/集成测试（如果测试框架可用）。
*   **规则 D.4 (可见标签) 符合性:**
    *   **缓解:** 尽力尝试添加可见标签，但依赖 `<meta>` 标签作为主要数据源。检查将报告符合性，接受可能存在的不符合。
*   **测试覆盖不足:**
    *   **缓解:** 最大化测试的覆盖范围（单元、集成、基础端到端）。接受视觉和复杂交互问题可能被遗漏。
*   **决策局限:**
    *   **缓解:** 基于预设规则和通用实践进行决策。允许后续手动调整。